package com.example.demo.service;

import com.example.demo.dto.PlayerState; // PlayerState DTO 임포트
import com.example.demo.dto.ObjectState; // ObjectState DTO 임포트 추가
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Map; // Map 인터페이스 사용 (ConcurrentHashMap 구현체)

@Service
public class PlayerService {

    private static final Logger logger = LoggerFactory.getLogger(PlayerService.class);

    // ConcurrentHashMap을 사용하여 스레드 안전하게 플레이어 상태를 관리합니다.
    // key: player ID (클라이언트에서 생성), value: PlayerState 객체
    private final Map<String, PlayerState> connectedPlayers = new ConcurrentHashMap<>();
    // key: sessionId (STOMP 연결 시 서버에서 할당), value: player ID
    // 세션 ID로 플레이어를 제거할 때 사용됩니다.
    private final Map<String, String> sessionToPlayerIdMap = new ConcurrentHashMap<>(); // 사용자 코드의 변수명 유지

    // 새로 추가: 동적 게임 오브젝트들의 상태를 관리하는 맵
    // key: 오브젝트 고유 ID (클라이언트에서 부여), value: ObjectState 객체
    private final Map<String, ObjectState> dynamicGameObjects = new ConcurrentHashMap<>();

    /**
     * 새로운 플레이어를 추가하거나, 기존 플레이어의 세션 ID 및 초기 상태를 업데이트합니다.
     * 클라이언트의 `id`를 기준으로 플레이어를 식별합니다.
     *
     * @param playerState 등록할 플레이어의 상태 (ID, 초기 위치 등)
     * @param sessionId 현재 연결의 세션 ID
     */
    public void addPlayer(PlayerState playerState, String sessionId) {
        if (playerState.getId() == null || playerState.getId().isEmpty()) {
            logger.error("Attempted to add player with null or empty ID.");
            return;
        }

        // 이미 존재하는 플레이어인지 확인 (클라이언트 ID 기준)
        if (connectedPlayers.containsKey(playerState.getId())) {
            // 플레이어가 이미 존재한다면, 세션 ID 및 최신 상태를 업데이트
            PlayerState existingPlayer = connectedPlayers.get(playerState.getId());
            String oldSessionId = existingPlayer.getSessionId(); // PlayerState에 getSessionId() 필요

            // 기존 세션 매핑 제거 (만약 이전 세션 ID가 다르고 유효하다면)
            if (oldSessionId != null && !oldSessionId.equals(sessionId) && sessionToPlayerIdMap.containsKey(oldSessionId)) {
                sessionToPlayerIdMap.remove(oldSessionId);
                logger.debug("Removed old session mapping for player {}: {}", playerState.getId(), oldSessionId);
            }

            // 플레이어 상태 업데이트 (위치, 회전 등 클라이언트가 보낸 최신 값으로)
            existingPlayer.setSessionId(sessionId); // 새로운 세션 ID로 업데이트 (PlayerState에 setSessionId() 필요)
            existingPlayer.setPosition(playerState.getPosition()); // 위치 업데이트
            existingPlayer.setRotationY(playerState.getRotationY()); // 회전 업데이트

            logger.info("Player {} re-registered and updated with new session {}. Old session: {}", playerState.getId(), sessionId, oldSessionId);
        } else {
            // 새로운 플레이어라면 추가
            playerState.setSessionId(sessionId); // 새 플레이어에게 세션 ID 설정
            connectedPlayers.put(playerState.getId(), playerState);
            logger.info("Player {} added with session {}", playerState.getId(), sessionId);
        }
        
        // 세션 ID와 플레이어 ID 매핑을 항상 최신으로 유지
        if (sessionId != null) {
            sessionToPlayerIdMap.put(sessionId, playerState.getId());
            logger.debug("Session-PlayerId map updated: {} -> {}", sessionId, playerState.getId());
        }
        logger.debug("Player count after add/update: {}", connectedPlayers.size());
    }

    /**
     * 특정 플레이어의 위치와 회전 정보를 업데이트합니다.
     *
     * @param playerId 업데이트할 플레이어의 고유 ID
     * @param newPosition 새로운 위치
     * @param newRotationY 새로운 Y축 회전 값
     */
    public void updatePlayerPosition(String playerId, PlayerState.Position newPosition, double newRotationY) {
        PlayerState player = connectedPlayers.get(playerId);
        if (player != null) {
            player.setPosition(newPosition);
            player.setRotationY(newRotationY);
            // 이 로그는 프레임마다 너무 많이 발생할 수 있으므로, 필요한 경우에만 활성화하세요.
            // logger.debug("Updated player {} position to ({}, {}, {})", playerId, newPosition.getX(), newPosition.getY(), newPosition.getZ());
        } else {
            logger.warn("Attempted to update non-existent player: {}", playerId);
        }
    }

    /**
     * 특정 플레이어 ID를 통해 플레이어를 제거합니다.
     *
     * @param playerId 제거할 플레이어의 고유 ID
     */
    public void removePlayerById(String playerId) {
        if (playerId != null) {
            PlayerState removedPlayer = connectedPlayers.remove(playerId);
            if (removedPlayer != null) {
                // 해당 플레이어 ID에 연결된 모든 세션 매핑 제거
                sessionToPlayerIdMap.entrySet().removeIf(entry -> entry.getValue().equals(playerId));
                logger.info("Player removed by ID: {}. Remaining: {}", playerId, connectedPlayers.size());
            } else {
                logger.warn("Attempted to remove non-existent player by ID: {}", playerId);
            }
        }
    }

    /**
     * 연결이 끊긴 세션 ID를 통해 플레이어를 제거합니다.
     * 이 메서드는 주로 WebSocketEventListener에서 세션 단절 시 호출됩니다.
     *
     * @param sessionId 제거할 세션의 ID
     */
    public void removePlayerBySessionId(String sessionId) {
        if (sessionId != null) {
            String playerId = sessionToPlayerIdMap.remove(sessionId); // 세션 ID로 플레이어 ID 찾아서 매핑 제거
            if (playerId != null) {
                connectedPlayers.remove(playerId); // 플레이어 ID로 플레이어 상태 제거
                logger.info("Player removed by Session ID: {} (Player ID: {}). Remaining: {}", sessionId, playerId, connectedPlayers.size());
            } else {
                logger.warn("Attempted to remove player for non-existent session: {}", sessionId);
            }
        }
    }

    /**
     * 현재 연결된 모든 플레이어의 상태를 반환합니다.
     *
     * @return 모든 플레이어 상태 객체의 컬렉션
     */
    public Collection<PlayerState> getAllPlayers() {
        return connectedPlayers.values();
    }

    /**
     * 주어진 ID에 해당하는 플레이어의 상태를 반환합니다.
     *
     * @param playerId 조회할 플레이어의 고유 ID
     * @return 플레이어 상태 객체, 없으면 null
     */
    public PlayerState getPlayerById(String playerId) {
        return connectedPlayers.get(playerId);
    }


    // ====== 새로 추가된 게임 오브젝트 관리 메서드 ======

    /**
     * 동적 게임 오브젝트를 추가하거나 업데이트합니다.
     *
     * @param objectState 업데이트할 오브젝트의 상태
     */
    public void addOrUpdateObject(ObjectState objectState) {
        if (objectState.getId() == null || objectState.getId().isEmpty()) {
            logger.error("Attempted to add/update object with null or empty ID.");
            return;
        }
        dynamicGameObjects.put(objectState.getId(), objectState);
        // logger.debug("Object {} added/updated. Total objects: {}", objectState.getId(), dynamicGameObjects.size());
    }

    /**
     * 특정 오브젝트의 상태를 업데이트합니다.
     *
     * @param objectId 업데이트할 오브젝트의 고유 ID
     * @param newPosition 새로운 위치
     * @param newRotation 새로운 회전 (쿼터니언)
     */
    public void updateObjectState(String objectId, ObjectState.Position newPosition, ObjectState.Rotation newRotation) {
        ObjectState object = dynamicGameObjects.get(objectId);
        if (object != null) {
            object.setPosition(newPosition);
            object.setRotation(newRotation);
            // 이 로그는 프레임마다 너무 많이 발생할 수 있으므로, 필요한 경우에만 활성화하세요.
            // logger.debug("Updated object {} position to ({}, {}, {})", objectId, newPosition.getX(), newPosition.getY(), newPosition.getZ());
        } else {
            logger.warn("Attempted to update non-existent object: {}", objectId);
        }
    }

    /**
     * 모든 동적 게임 오브젝트의 상태를 반환합니다.
     *
     * @return 모든 오브젝트 상태 객체의 컬렉션
     */
    public Collection<ObjectState> getAllObjects() {
        return dynamicGameObjects.values();
    }

    /**
     * 특정 오브젝트 ID를 통해 오브젝트를 제거합니다.
     * (일반적으로 물리 오브젝트는 게임 플레이 중 제거될 일이 적지만, 필요하다면 구현)
     * @param objectId 제거할 오브젝트의 고유 ID
     */
    public void removeObjectById(String objectId) {
        if (objectId != null) {
            dynamicGameObjects.remove(objectId);
            logger.info("Object removed by ID: {}. Remaining objects: {}", objectId, dynamicGameObjects.size());
        }
    }
}
