package com.example.demo.service;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import com.example.demo.dto.PlayerState;

import java.util.Collection;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Map;

@Service // Spring Bean으로 등록하여 다른 컴포넌트에서 주입받아 사용할 수 있게 함
public class PlayerService {

 private static final Logger logger = LoggerFactory.getLogger(PlayerService.class);

 // 모든 연결된 플레이어의 상태를 저장하는 맵
 // key: player id (프론트에서 생성), value: PlayerState 객체
 private final Map<String, PlayerState> connectedPlayers = new ConcurrentHashMap<>();

 // WebSocket 세션 ID와 플레이어 ID를 매핑하는 맵 (연결 해제 시 플레이어 ID를 찾기 위해 사용)
 // key: WebSocket Session ID, value: Player ID
 private final Map<String, String> sessionToPlayerIdMap = new ConcurrentHashMap<>();

 /**
  * 새로운 플레이어를 추가하거나 기존 플레이어의 세션 ID를 업데이트합니다.
  * @param playerState 추가 또는 업데이트할 플레이어 상태
  * @param sessionId 해당 플레이어의 현재 WebSocket 세션 ID
  */
 public void addPlayer(PlayerState playerState, String sessionId) {
     if (playerState.getId() == null || playerState.getId().isEmpty()) {
         logger.error("Attempted to add player with null or empty ID.");
         return;
     }

     connectedPlayers.put(playerState.getId(), playerState);
     if (sessionId != null) {
         sessionToPlayerIdMap.put(sessionId, playerState.getId());
     }
     logger.debug("Player added/updated in service: {} (Session: {})", playerState.getId(), sessionId);
 }

 /**
  * 기존 플레이어의 상태를 업데이트합니다.
  * (주로 위치/회전 변경 시 사용)
  * @param playerState 업데이트할 플레이어 상태
  */
 public void updatePlayer(PlayerState playerState) {
     if (playerState.getId() == null || playerState.getId().isEmpty()) {
         logger.error("Attempted to update player with null or empty ID.");
         return;
     }
     connectedPlayers.put(playerState.getId(), playerState); // 기존에 없으면 추가, 있으면 업데이트
     logger.debug("Player state updated in service: {}", playerState.getId());
 }

 /**
  * 플레이어 ID를 사용하여 플레이어를 목록에서 제거합니다.
  * @param playerId 제거할 플레이어의 ID
  */
 public void removePlayerById(String playerId) {
     if (playerId != null) {
         connectedPlayers.remove(playerId);
         // sessionToPlayerIdMap에서도 제거 (역으로 찾아서, 효율적이지 않지만 정확성을 위해)
         // 실제 구현에서는 sessionId를 알 때 removePlayerBySessionId를 사용하는 것이 더 좋음
         sessionToPlayerIdMap.entrySet().removeIf(entry -> entry.getValue().equals(playerId));
         logger.info("Player removed by ID: {}. Remaining: {}", playerId, connectedPlayers.size());
     }
 }

 /**
  * WebSocket 세션 ID를 사용하여 플레이어를 목록에서 제거합니다.
  * (주로 WebSocket 연결 끊김 이벤트 처리 시 사용)
  * @param sessionId 제거할 플레이어의 WebSocket 세션 ID
  */
 public void removePlayerBySessionId(String sessionId) {
     if (sessionId != null) {
         String playerId = sessionToPlayerIdMap.remove(sessionId); // 세션 ID로 플레이어 ID 얻고 맵에서 제거
         if (playerId != null) {
             connectedPlayers.remove(playerId); // 플레이어 ID로 플레이어 상태 제거
             logger.info("Player removed by Session ID: {} (Player ID: {}). Remaining: {}", sessionId, playerId, connectedPlayers.size());
         } else {
             logger.warn("Attempted to remove non-existent player for session ID: {}", sessionId);
         }
     }
 }

 /**
  * 현재 접속 중인 모든 플레이어의 상태 목록을 반환합니다.
  * @return 모든 플레이어 상태의 Collection
  */
 public Collection<PlayerState> getAllPlayers() {
     return connectedPlayers.values();
 }

 /**
  * 특정 플레이어 ID에 해당하는 플레이어 상태를 반환합니다.
  * @param playerId 찾을 플레이어의 ID
  * @return 해당 플레이어의 PlayerState 객체, 없으면 null
  */
 public PlayerState getPlayerById(String playerId) {
     return connectedPlayers.get(playerId);
 }
}