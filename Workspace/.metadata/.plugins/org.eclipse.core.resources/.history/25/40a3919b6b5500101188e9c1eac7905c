package com.example.demo.controller;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.simp.SimpMessageHeaderAccessor;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping; // Hello 테스트를 위해 유지

import com.example.demo.dto.PlayerState;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Controller
public class GameController {

    private static final Logger logger = LoggerFactory.getLogger(GameController.class);
    private final SimpMessagingTemplate messagingTemplate; // 메시지를 브로드캐스팅하는 데 사용
    private final Map<String, PlayerState> connectedPlayers = new ConcurrentHashMap<>(); // 접속 플레이어 상태 저장

    public GameController(SimpMessagingTemplate messagingTemplate) {
        this.messagingTemplate = messagingTemplate;
    }


    /**
     * 플레이어가 접속 시 호출됩니다.
     * /app/registerPlayer 로 메시지가 옵니다.
     */
    @MessageMapping("/registerPlayer")
    public void registerPlayer(PlayerState playerState, SimpMessageHeaderAccessor headerAccessor) {
        // 세션 ID를 플레이어 ID로 사용하여 Map에 저장합니다.
        // 실제로는 playerState.getId()를 사용하고, 세션 관리는 WebSocketEventListener에서 하는 것이 더 일반적입니다.
        // 여기서는 예시로 playerState.getId()를 사용합니다.
        connectedPlayers.put(playerState.getId(), playerState);
        logger.info("Player registered: {}", playerState.getId());
        // 모든 클라이언트에게 현재 접속 중인 모든 플레이어의 상태를 전송합니다.
        messagingTemplate.convertAndSend("/topic/playerLocations", connectedPlayers.values());
    }

    /**
     * 플레이어의 움직임 정보가 업데이트될 때 호출됩니다.
     * /app/playerMove 로 메시지가 옵니다.
     */
    @MessageMapping("/playerMove")
    public void playerMove(PlayerState playerState) {
        connectedPlayers.put(playerState.getId(), playerState); // 플레이어 상태 업데이트
        // logger.debug("Player moved: {}", playerState.getId()); // 너무 많은 로그가 찍힐 수 있으니 디버그 레벨로
        // 모든 클라이언트에게 현재 접속 중인 모든 플레이어의 상태를 전송합니다.
        messagingTemplate.convertAndSend("/topic/playerLocations", connectedPlayers.values());
    }

    /**
     * 플레이어가 접속을 해제할 때 호출됩니다. (프론트에서 명시적으로 보낼 때)
     * 실제로는 WebSocketEventListener에서 세션 종료 이벤트를 처리하는 것이 일반적입니다.
     */
    @MessageMapping("/unregisterPlayer")
    public void unregisterPlayer(PlayerState playerState) {
        connectedPlayers.remove(playerState.getId());
        logger.info("Player unregistered: {}", playerState.getId());
        // 모든 클라이언트에게 업데이트된 플레이어 목록을 전송합니다.
        messagingTemplate.convertAndSend("/topic/playerLocations", connectedPlayers.values());
    }
}