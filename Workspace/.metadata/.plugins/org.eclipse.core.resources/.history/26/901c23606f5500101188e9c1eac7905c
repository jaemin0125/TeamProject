package com.example.demo.controller;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.simp.SimpMessageHeaderAccessor;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;

import com.example.demo.dto.PlayerState;
import com.example.demo.service.PlayerService;

@Controller
public class GameController {

 private static final Logger logger = LoggerFactory.getLogger(GameController.class);
 private final SimpMessagingTemplate messagingTemplate;
 private final PlayerService playerService;

 public GameController(SimpMessagingTemplate messagingTemplate, PlayerService playerService) {
     this.messagingTemplate = messagingTemplate;
     this.playerService = playerService;
 }

 // 간단한 HTTP GET 요청 예시 (필요 없으면 삭제해도 무방)
 @GetMapping("/api/hello")
 public String hello() {
     logger.info("Hello from Spring Boot server (HTTP request)!");
     return "Hello from Spring Boot!";
 }

 /**
  * 플레이어가 접속 시 호출됩니다.
  * 클라이언트에서 /app/registerPlayer 로 메시지를 보냅니다.
  * @param playerState 클라이언트가 보낸 플레이어 초기 상태
  * @param headerAccessor WebSocket 세션 정보에 접근하기 위한 객체
  */
 @MessageMapping("/registerPlayer")
 public void registerPlayer(PlayerState playerState, SimpMessageHeaderAccessor headerAccessor) {
     String sessionId = headerAccessor.getSessionId(); // 클라이언트 WebSocket 세션 ID 가져오기
     playerState.setSessionId(sessionId); // PlayerState에 세션 ID 설정 (선택 사항이나 디버깅에 유용)

     playerService.addPlayer(playerState, sessionId); // PlayerService를 통해 플레이어 추가
     logger.info("Player registered: {} (Session: {})", playerState.getId(), sessionId);

     // 모든 클라이언트에게 현재 접속 중인 모든 플레이어의 상태를 전송합니다.
     // 이 메시지를 받은 클라이언트는 화면에 다른 플레이어들을 렌더링하거나 업데이트합니다.
     messagingTemplate.convertAndSend("/topic/playerLocations", playerService.getAllPlayers());
 }

 /**
  * 플레이어의 움직임 정보가 업데이트될 때 호출됩니다.
  * 클라이언트에서 /app/playerMove 로 메시지를 보냅니다.
  * @param playerState 업데이트된 플레이어 상태 (위치, 회전 등)
  */
 @MessageMapping("/playerMove")
 public void playerMove(PlayerState playerState) {
     // 플레이어 서비스에서 기존 플레이어의 세션ID를 유지하고 위치만 업데이트 (정확한 구현을 위해)
     PlayerState existingPlayer = playerService.getPlayerById(playerState.getId());
     if (existingPlayer != null) {
         existingPlayer.setPosition(playerState.getPosition());
         existingPlayer.setRotationY(playerState.getRotationY());
         playerService.updatePlayer(existingPlayer); // PlayerService를 통해 플레이어 상태 업데이트
     } else {
         // 만약 없는 플레이어의 움직임 정보가 온다면, 일단 추가 (비정상 케이스일 수 있음)
         logger.warn("Received move for unknown player: {}", playerState.getId());
         // TODO: 세션 ID 없이 등록될 경우 문제가 될 수 있으므로, 실제 앱에서는 이러한 경우를 더 잘 처리해야 합니다.
         // 여기서는 단순화를 위해 임시적으로 처리
         playerService.addPlayer(playerState, null); // 세션 ID가 없는 경우
     }


     // 모든 클라이언트에게 현재 접속 중인 모든 플레이어의 상태를 브로드캐스팅합니다.
     messagingTemplate.convertAndSend("/topic/playerLocations", playerService.getAllPlayers());
 }

 /**
  * 플레이어가 명시적으로 접속을 해제할 때 호출됩니다.
  * (프론트엔드에서 beforeunload 같은 이벤트로 메시지를 보낼 때)
  * 실제로는 WebSocketEventListener에서 세션 종료 이벤트를 처리하는 것이 더 안정적입니다.
  * @param playerState 해제하려는 플레이어의 ID를 포함한 상태
  */
 @MessageMapping("/unregisterPlayer")
 public void unregisterPlayer(PlayerState playerState) {
     playerService.removePlayerById(playerState.getId()); // PlayerService를 통해 플레이어 제거
     logger.info("Player unregistered by client: {}", playerState.getId());
     // 모든 클라이언트에게 업데이트된 플레이어 목록을 전송합니다.
     messagingTemplate.convertAndSend("/topic/playerLocations", playerService.getAllPlayers());
 }
}