package com.example.demo.config;


import org.springframework.context.event.EventListener;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.simp.SimpMessageHeaderAccessor;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.messaging.SessionDisconnectEvent;

import com.example.demo.dto.Player;

import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors; // Collectors 임포트 추가

@Component
public class WebSocketEventListener {

    private final SimpMessagingTemplate messagingTemplate;
    private final Map<String, Player> connectedPlayers = new ConcurrentHashMap<>();

    public WebSocketEventListener(SimpMessagingTemplate messagingTemplate) {
        this.messagingTemplate = messagingTemplate;
    }

    @MessageMapping("/registerPlayer")
    public void registerPlayer(Player player, SimpMessageHeaderAccessor headerAccessor) {
        String playerId = player.getId();
        String sessionId = headerAccessor.getSessionId();
        player.setSessionId(sessionId);
        connectedPlayers.put(playerId, player);
        System.out.println("Player registered: " + player.getId() + " (Session: " + sessionId + ")");
        
        broadcastPlayerLocations();
    }

    @EventListener
    public void handleWebSocketDisconnectListener(SessionDisconnectEvent event) {
        SimpMessageHeaderAccessor headerAccessor = SimpMessageHeaderAccessor.wrap(event.getMessage());
        String disconnectedSessionId = headerAccessor.getSessionId();

        // 연결 끊긴 세션 ID에 해당하는 플레이어 찾아서 제거
        connectedPlayers.entrySet().removeIf(entry -> {
            Player player = entry.getValue();
            // sessionId가 null이거나 일치하지 않으면 false (제거 안 함)
            // sessionId가 일치하면 true (제거)
            if (player.getSessionId() != null && player.getSessionId().equals(disconnectedSessionId)) {
                System.out.println("Player disconnected (Server Event): " + player.getId() + " (Session: " + disconnectedSessionId + ")");
                return true; 
            }
            return false;
        });
        
        broadcastPlayerLocations();
    }

    @MessageMapping("/playerMove")
    public void playerMove(Player player) {
        if (connectedPlayers.containsKey(player.getId())) {
            Player existingPlayer = connectedPlayers.get(player.getId());
            existingPlayer.setPosition(player.getPosition());
            existingPlayer.setRotationY(player.getRotationY());
        }
        broadcastPlayerLocations();
    }`

    @MessageMapping("/unregisterPlayer")
    public void unregisterPlayer(Player player) {
        String playerId = player.getId();
        if (connectedPlayers.containsKey(playerId)) {
            connectedPlayers.remove(playerId);
            System.out.println("Player unregistered (Client Request): " + playerId);
            broadcastPlayerLocations();
        }
    }

    // 모든 클라이언트에게 현재 플레이어 위치 브로드캐스트
    private void broadcastPlayerLocations() {
        // Map의 values()를 List로 변환하여 전송
        List<Player> playersList = connectedPlayers.values().stream().collect(Collectors.toList());
        messagingTemplate.convertAndSend("/topic/playerLocations", playersList);
    }
}