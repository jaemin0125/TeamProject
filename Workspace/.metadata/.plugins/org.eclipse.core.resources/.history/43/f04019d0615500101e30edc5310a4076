package com.example.demo.config;


import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.context.event.EventListener;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.simp.SimpMessageHeaderAccessor;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.messaging.SessionDisconnectEvent;

import com.example.demo.dto.Player;

@Component
public class WebSocketEventListener {

 private final SimpMessagingTemplate messagingTemplate;
 // 모든 플레이어의 상태를 저장하는 맵 (Thread-safe하게 ConcurrentHashMap 사용)
 private final Map<String, Player> connectedPlayers = new ConcurrentHashMap<>();

 public WebSocketEventListener(SimpMessagingTemplate messagingTemplate) {
     this.messagingTemplate = messagingTemplate;
 }

 // 클라이언트 연결 시 (플레이어 등록)
 @MessageMapping("/registerPlayer")
 public void registerPlayer(Player player, SimpMessageHeaderAccessor headerAccessor) {
     // 클라이언트에서 보낸 ID를 사용하거나, 세션 ID를 사용할 수 있음
     // 여기서는 클라이언트에서 보낸 ID를 사용 (currentPlayerId)
     String playerId = player.getId();
     // 웹소켓 세션 ID를 플레이어와 연결하여 나중에 DISCONNECT 이벤트에서 찾기 위함
     String sessionId = headerAccessor.getSessionId();
     player.setSessionId(sessionId); // Player 모델에 sessionId 필드를 추가했다고 가정
     connectedPlayers.put(playerId, player);
     System.out.println("Player registered: " + player.getId() + " (Session: " + sessionId + ")");
     
     // 모든 클라이언트에게 현재 플레이어 목록 브로드캐스트
     broadcastPlayerLocations();
 }

 // 클라이언트 연결 끊김 시 (서버 측에서 감지)
 @EventListener
 public void handleWebSocketDisconnectListener(SessionDisconnectEvent event) {
     SimpMessageHeaderAccessor headerAccessor = SimpMessageHeaderAccessor.wrap(event.getMessage());
     String disconnectedSessionId = headerAccessor.getSessionId();

     // 연결 끊긴 세션 ID에 해당하는 플레이어 찾아서 제거
     connectedPlayers.entrySet().removeIf(entry -> {
         Player player = entry.getValue();
         if (player.getSessionId() != null && player.getSessionId().equals(disconnectedSessionId)) {
             System.out.println("Player disconnected (Server Event): " + player.getId() + " (Session: " + disconnectedSessionId + ")");
             return true; // 맵에서 제거
         }
         return false;
     });
     
     // 모든 클라이언트에게 업데이트된 플레이어 목록 브로드캐스트
     broadcastPlayerLocations();
 }

 // 플레이어 이동 메시지 처리
 @MessageMapping("/playerMove")
 public void playerMove(Player player) {
     // 맵에 이미 존재하는 플레이어의 위치/회전 정보 업데이트
     if (connectedPlayers.containsKey(player.getId())) {
         Player existingPlayer = connectedPlayers.get(player.getId());
         existingPlayer.setPosition(player.getPosition());
         existingPlayer.setRotationY(player.getRotationY());
     }
     // 모든 클라이언트에게 업데이트된 플레이어 목록 브로드캐스트
     broadcastPlayerLocations();
 }

 // 클라이언트가 명시적으로 연결 해제 요청 시
 @MessageMapping("/unregisterPlayer")
 public void unregisterPlayer(Player player) {
     String playerId = player.getId();
     if (connectedPlayers.containsKey(playerId)) {
         connectedPlayers.remove(playerId);
         System.out.println("Player unregistered (Client Request): " + playerId);
         // 모든 클라이언트에게 업데이트된 플레이어 목록 브로드캐스트
         broadcastPlayerLocations();
     }
 }

 // 모든 클라이언트에게 현재 플레이어 위치 브로드캐스트
 private void broadcastPlayerLocations() {
     // connectedPlayers 맵의 모든 Player 객체들을 리스트로 변환하여 전송
     messagingTemplate.convertAndSend("/topic/playerLocations", connectedPlayers);
 }
}